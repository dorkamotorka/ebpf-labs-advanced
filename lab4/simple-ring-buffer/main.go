package main

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -target amd64 ring ring.c

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

// Must match the C struct layout exactly!
type event struct {
	PID      uint32
	TGID     uint32
	Filename [256]byte
}

func cString(b []byte) string {
	// Convert a null-terminated C string buffer into a Go string.
	n := bytes.IndexByte(b, 0)
	if n == -1 {
		n = len(b)
	}
	return string(b[:n])
}

func main() {
	// Remove resource limits for kernels <5.11.
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatal("Removing memlock:", err)
	}

	// Load the compiled eBPF ELF and load it into the kernel.
	var objs ringObjects
	if err := loadRingObjects(&objs, nil); err != nil {
		log.Fatal("Loading eBPF objects:", err)
	}
	defer objs.Close()

	// Attach Tracepoint
	tp, err := link.Tracepoint("syscalls", "sys_enter_execve", objs.HandleExecveTp, nil)
	if err != nil {
		log.Fatalf("Attaching Tracepoint: %s", err)
	}
	defer tp.Close()
	log.Printf("Successfully attached eBPF Tracepoint...")

	// Open a ring buffer reader on the "events" map generated by bpf2go.
	// bpf2go exposes it as objs.Events.
	rb, err := ringbuf.NewReader(objs.Events)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %v", err)
	}
	defer rb.Close()

	// Signal handling / context.
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	// Reader loop in a goroutine so we can cancel via context.
	errCh := make(chan error, 1)
	go func() {
		defer close(errCh)
		var ev event

		for {
			rec, err := rb.Read()
			if err != nil {
				// When Close() is called, Read() returns an error; exit cleanly.
				errCh <- err
				return
			}
			// Decode into our event struct (little-endian).
			if err := binary.Read(bytes.NewReader(rec.RawSample), binary.LittleEndian, &ev); err != nil {
				fmt.Printf("failed to decode event: %v\n", err)
				continue
			}
			fmt.Printf("execve pid=%d tgid=%d file=%q\n",
				ev.PID, ev.TGID, cString(ev.Filename[:]))
		}
	}()

	// Wait for SIGINT/SIGTERM (Ctrl+C) before exiting
	<-ctx.Done()
	log.Println("Received signal, exiting...")

	// Stop the reader and drain any error.
	_ = rb.Close()
	<-errCh
}
