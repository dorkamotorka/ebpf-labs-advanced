# Verbose/non-verbose command execution
ifeq ($(V),1)
Q =
msg =
else
Q = @
msg = @printf '  %-8s %s%s\n' "$(1)" "$(notdir $(2))" "$(if $(3), $(3))";
endif

ifndef BTFHUB_ARCHIVE
$(error BTFHUB_ARCHIVE is undefined)
endif

ifndef ARCH
$(error ARCH is undefined)
endif

ifndef OUTPUT
$(error OUTPUT directory for BTF files is undefined)
endif

# Find all relevant .btf.tar.xz files in BTFHub archive that match the architecture
SOURCE_BTF_FILES = $(shell find $(BTFHUB_ARCHIVE)/ -iregex ".*$(subst x86,x86_64,$(ARCH)).*" -type f -name '*.btf.tar.xz')

# Map each source BTF file to its expected minimal BTF output path
MIN_CORE_BTF_FILES = $(patsubst $(BTFHUB_ARCHIVE)/%.btf.tar.xz, $(OUTPUT)/$(ARCH)/%.btf, $(SOURCE_BTF_FILES))

# BPF objects in the current dir matching "*<arch>.o" or "*bpfel.o"
BPF_ALL_O_FILES = $(shell find . -maxdepth 1 -type f -regex '.*/.*\($(ARCH)\|bpfel\)\.o$$')

# Default target: generate all minimal BTF files
.PHONY: all
all: $(MIN_CORE_BTF_FILES)

$(MIN_CORE_BTF_FILES): $(BPF_PROGS_O_FILES)

# Rule to generate a minimal BTF file from a .btf.tar.xz archive
# Unpacks the archive, runs bpftool to generate the minimal BTF,
# and then deletes the extracted full BTF file
$(OUTPUT)/$(ARCH)/%.btf: BTF_FILE = $(<:.tar.xz=)
$(OUTPUT)/$(ARCH)/%.btf: $(BTFHUB_ARCHIVE)/%.btf.tar.xz
	$(call msg,UNTAR,$@)
	$(Q)tar xvfJ $< -C "$(dir $<)" --touch > /dev/null
	$(call msg,BTFGEN,$@)
	$(Q)mkdir -p "$(@D)"
	$(Q)if [ -f $(BTF_FILE) ]; then bpftool gen min_core_btf $(BTF_FILE) $@ $(BPF_ALL_O_FILES); else echo "$(BTF_FILE) does not exist!" >&2; fi
	$(Q)rm -fr $(BTF_FILE)
